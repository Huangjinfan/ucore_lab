# Lab3 Report
## 黄欢 2013011331 计33

---

**练习0：填写已有实验**

本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

> LAB1 diff result

> kern/debug/kdebug.c:	step1

> kern/trap/trap.c:		step2, step3, challenge1

> kern/init/init.c:		challenge1

> LAB2 diff result

> kern/mm/default_pmm.c:step1

> kern/mm/pmm.c:        step2, step3

---

**练习1：给未被映射的地址映射上物理页（需要编程）**

完成do\_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限
的时候需要参考页面所在 VMA
的权限，同时需要注意映射物理页时需要操作内存控制
结构所指定的页表，而不是内核的页表。注意：在LAB2 EXERCISE
1处填写代码。执行
```
make　qemu
```
后，如果通过check\_pgfault函数的测试后，会有“check\_pgfault()
succeeded!”的输出，表示练习1基本正确。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

 - 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
 - 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

---

答：

设计实现过程：调用get_pte，根据所访问的线性地址从mm管理的页目录中取得该地址所在也的页表项，若该页表项所在的页表不在内存中则get_pte自动会为该页表分配页。取出页表项后，若对应页不存在且未曾换出过则直接为该页表项分配新页，分配新页使用pgdir_alloc_page函数，若该页换出过，则将其换入，换入使用swap_in函数，换入后需要调用page_insert将换入的页插入到mm管理的页目录中，然后调用swap_map_swappable将该页设置为可换出。

---

 - 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。

 答：
 ```
 页目录表项，页表项的组成
 DIR_ENTRY = [高20位：二级页表地址的高20位（4KB对齐）][低12位属性]PT_ENTRY = [高20位：物理页帧地址的高20位（4KB对齐）][低12位属性]
 /* page table/directory entry flags */
 #define PTE_P           0x001                   // Present
 #define PTE_W           0x002                   // Writeable
 #define PTE_U           0x004                   // User
 #define PTE_PWT         0x008                   // Write-Through
 #define PTE_PCD         0x010                   // Cache-Disable
 #define PTE_A           0x020                   // Accessed
 #define PTE_D           0x040                   // Dirty
 #define PTE_PS          0x080                   // Page Size
 #define PTE_MBZ         0x180                   // Bits must be zero
 #define PTE_AVAIL       0xE00                   // Available for software use
                                                // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
                                                // hardware, so user processes are allowed to set them arbitrarily.
```

 pte保存页地址或换出时的扇区地址，这是换入换出的一个主要参数。pte中由于页地址和扇区地址低4位都是0，可以利用这4位保存一些标志标志位，如存在位、修改位等，这些为替换算法选择替换页提供了依据。具体来说，若页表或者页不在内存中，则需要从硬盘中读取；Clock算法需要记录页是否被访问；替换页时，还需查看PTE_D，若是脏页，则替换时需要更新内容到硬盘中。

---

 - 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

 答：

 由于页访问异常属于内中断，不可屏蔽，可以在指令的寻址阶段中断当前指令，由于缺页服务例程缺页也会产生缺页终端因此会无限中断下去，此时主机无法工作下去，只能重启，此时硬件需要重置所有寄存器，重启系统。

---

**练习2：补充完成基于FIFO的页面替换算法（需要编程）**

完成vmm.c中的do\_pgfault函数，并且在实现FIFO算法的swap\_fifo.c中完成map\_swappable和swap\_out\_vistim函数。通过对swap的测试。注意：在LAB2
EXERCISE 2处填写代码。执行
```
make　qemu
```
后，如果通过check\_swap函数的测试后，会有“check\_swap()
succeeded!”的输出，表示练习2基本正确。

请在实验报告中简要说明你的设计实现过程。

请在实验报告中回答如下问题：

 - 如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题
   - 需要被换出的页的特征是什么？
   - 在ucore中如何判断具有这样特征的页？
   - 何时进行换入和换出操作？

 ---

答：
设计实现过程：

1. `_fifo_map_swappable`：把`page`插入mm管理的工作页链表尾部，调用`list_add`实现链表插入

2. `_fifo_swap_out_victim`：取出mm管理的工作页链表头部的`page`，再从链表中用`list_del`删除这个`page`

---

 - 如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题
   - 需要被换出的页的特征是什么？
   - 在ucore中如何判断具有这样特征的页？
   - 何时进行换入和换出操作？

 答：
 - extended clock算法是对LRU算法的简化，需要被换出的页是最久未使用的页面。最优先换出的是未修改且未访问过的页，其次是修改过且未访问过的页。若没有未访问过的页，则扫描访问过的页时会将访问位置0，然后再从头扫描。
 - 在pte或page中加入两个标志位：访问位和修改位。
 - 换入时访问位初始化为1，修改位初始化为0，将页链接到mm管理的工作页链表中；换出时，扫描mm管理的工作页链表按照clock算法依据修改位和访问位选择换出页，然后把换出页从mm管理的工作页链表中删除。其他操作与FIFO一致。


---

## [Others]

**完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别**

根据理解进行分析和尝试，有问题的地方参考提供的答案进行理解。
所有部分仔细地实践一遍。

**列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）**

#### 基本原理概述

虚拟内存，简单地说是指程序员或CPU“看到”的内存。但有几点需要注意：

 1. 虚拟内存单元不一定有实际的物理内存单元对应，即实际的物理内存单元可能不存在；
 2. 如果虚拟内存单元对应有实际的物理内存单元，那二者的地址一般是不相等的；
 3. 通过操作系统实现的某种内存映射可建立虚拟内存与物理内存的对应关系，使得程序员或CPU访问的虚拟内存地址会自动转换为一个物理内存地址。

那么这个“虚拟”的作用或意义在哪里体现呢？在操作系统中，虚拟内存其实包含多个虚拟层次，在不同的层次体现了不同的作用。首先，在有了分页机制后，程序员或CPU“看到”的地址已经不是实际的物理地址了，这已经有一层虚拟化，我们可简称为内存地址虚拟化。有了内存地址虚拟化，我们就可以通过设置页表项来限定软件运行时的访问空间，确保软件运行不越界，完成内存访问保护的功能。

通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页（demand paging）。把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中，这种技术称为页换入换出（page　swap in/out）。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。

#### Page Fault异常处理

实现虚存管理的一个关键是page fault异常处理，其过程中主要涉及到函数 -- do\_pgfault的具体实现。比如，在程序的执行过程中由于某种原因（页框不存在/写只读页等）而使 CPU 无法最终访问到相应的物理内存单元，即无法完成从虚拟地址到物理地址映射时，CPU 会产生一次页访问异常，从而需要进行相应的页访问异常的中断服务例程。这个页访问异常处理的时机被操作系统充分利用来完成虚存管理，即实现“按需调页”/“页换入换出”处理的执行时机。当相关处理完成后，页访问异常服务例程会返回到产生异常的指令处重新执行，使得应用软件可以继续正常运行下去。

具体而言，当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误（比如写一个只读页或用户态程序访问内核态的数据等），就会发生页访问异常。产生页访问异常的原因主要有：

*  目标页帧不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)；
*  相应的物理页帧不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)，这在本次实验中会出现，我们将在下面介绍换页机制实现时进一步讲解如何处理；
*  不满足访问权限(此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面).

当出现上面情况之一，那么就会产生页面page fault（\#PF）异常。CPU会把产生异常的线性地址存储在CR2中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。

#### 页替换算法

操作系统为何要进行页面置换呢？这是由于操作系统给用户态的应用程序提供了一个虚拟的“大容量”内存空间，而实际的物理内存空间又没有那么大。

本次实验涉及的页替换算法：

* 先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIFO算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使页访问异常次数增多。

* 时钟（Clock）页替换算法：是LRU算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页。

* 改进的时钟（Enhanced Clock）页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为淘汰修改过的页面还需要写回硬盘，使得其置换代价大于未修改过的页面，所以优先淘汰没有修改的页，减少磁盘操作次数。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的I/O操作次数，但为了查找到一个尽可能适合淘汰的页面，可能需要经过多次扫描，增加了算法本身的执行开销。

#### 页面置换算法

页面置换算法分为局部页面置换算法和全局页面置换算法。

区别在于置换页面的选择范围，对于局部置换算法仅限于当前进程占用的物理页面内；对于全局页面置换算法而言则是所有可换出的物理页面。

- 局部页面置换算法主要有最优算法、先进先出算法、最近最久未使用算法、时钟算法、最不常用算法。

最优页面置换算法：
> 思路：置换在未来最长时间不访问的页面

> 实现：缺页时，计算内存每个逻辑页面的下一次访问时间选择未来最长时间不访问的页面

> 特征：缺页最少，是理想情况，实际系统中无法实现无法预知每个页面在下一次访问前的等待时间

先进先出算法：
> 思路：选择在内存中驻留时间最长的页面进行置换

> 实现：维护一个记录所有位于内存中的逻辑页面链表，链表元素按驻留内存的时间排序，链首最长，链尾最短；出现缺页时，选择链首页面进行置换，新页面加到链尾

> 特征：实现简单，性能较差，调出的页面可能会被经常访问；进程分配物理页面数增加时，缺页并不一定减少；很少单独使用

最近最久未使用算法：
> 思路：选择最长时间没有被引用的页面置换，基于假设若某些页面长时间未被访问，则它们在将来很长一段时间不会被访问

> 实现：缺页时，计算内存中每个逻辑页面的上一次访问的时间，选择上一次使用到当前时间最长的页面

> 特征：是最优置换算法的一种近似

时钟算法：
> 思路：仅对页面的访问情况进行大致统计

> 实现：在页表项中增加访问位，描述页面在过去一段时间的内访问情况；各页面组织成环形链表；指针指向最先调入的页面；访问页面时，在页表项记录页面访问情况；缺页时，从指针处开始顺序查找未被访问的页面进行置换

最不常用算法：
> 思路：缺页时，置换访问次数最少的页面

> 实现：每个页面设置一个访问计数器；访问页面时，访问计数加1；缺页时，置换计数最小的页面

> 特征：算法开销大；开始时频繁使用，但以后不使用的页面很难置换

- 全局页面置换算法主要有工作集算法、缺页率算法。

工作集算法：
> 思路：换出不在工作集中的页面

> 实现：访存链表：维护窗口内的访存页面链表；访存时，换出不在工作集的页面，更新访存链表；缺页时，换入页面，更新访存链表

缺页率算法：
> 思路：通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内；若进程缺页率过高，则增加常驻集以分配更多的物理页面；若进程缺页率过低，则减少常驻集以减少它的物理页面数

> 实现：访存时，设置引用位标志；缺页时，计算从上次缺页时间到现在的时间间隔；若时间间隔大于定值T，则置换所有在这段时间内没有被引用的页面；否则，则增加缺失页到工作集中
